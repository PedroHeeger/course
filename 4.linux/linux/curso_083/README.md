# Linux Essentials   <img src="./0-aux/logo_course.jpg" alt="curso_083" width="auto" height="45">

### Repository: [course](../../../)   
### Platform: <a href="../../">4.Linux   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/plataforma/4.linux.png" alt="4.linux" width="auto" height="25"></a>   
### Software/Subject: <a href="../">linux   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/linux/linux-original.svg" alt="linux" width="auto" height="25"></a>
### Course: <a href="./">curso_083 (Linux Essentials)   <img src="./0-aux/logo_course.jpg" alt="curso_083" width="auto" height="25"></a>

#### <a href="https://github.com/PedroHeeger/main/blob/main/cert_ti/04-curso/os/linux/(23-08-22)%20Linux%20Fundamentals%20PH%204.Linux.pdf">Certificate</a>

---

### Theme:
- Operating System (OS)

### Used Tools:
- Operating System (OS): 
  - Linux <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/linux/linux-original.svg" alt="linux" width="auto" height="25">
  - Windows 11 <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/windows11.png" alt="windows11" width="auto" height="25">
- Linux Distribution: 
  - Ubuntu <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/ubuntu/ubuntu-plain.svg" alt="ubuntu" width="auto" height="25">
- Virtualization: 
  - Oracle VM VirtualBox   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/vm_virtualbox.png" alt="vm_virtualbox" width="auto" height="25">
- Cloud Services:
  - Google Drive <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/google_drive.png" alt="google_drive" width="auto" height="25">
- Language:
  - HTML   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/html5/html5-original.svg" alt="html" width="auto" height="25">
  - Markdown   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/markdown/markdown-original.svg" alt="markdown" width="auto" height="25">
- Integrated Development Environment (IDE) and Text Editor:
  - Nano   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/nano.png" alt="nano" width="auto" height="25">
  - Vi   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/vi.png" alt="vi" width="auto" height="25">
  - VI iMproved (Vim)   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/vim/vim-original.svg" alt="vim" width="auto" height="25">
  - Visual Studio Code (VS Code)   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/vscode/vscode-original.svg" alt="vscode" width="auto" height="25">
- Versioning: 
  - Git   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/git/git-original.svg" alt="git" width="auto" height="25">
- Repository:
  - GitHub   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/github/github-original.svg" alt="github" width="auto" height="25">
- Command Line Interpreter (CLI):
  - Bash e Sh   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/bash/bash-original.svg" alt="bash_sh" width="auto" height="25">
- Tools:
  - Advanced Package Tool (Apt)   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/apt.png" alt="apt" width="auto" height="25">
  - Advanced Package Tool (Apt-Get)   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/apt-get.jpg" alt="apt-get" width="auto" height="25">
  - Aptitude   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/aptitude.webp" alt="aptitude" width="auto" height="25">
  - Bzip2/Bunzip2   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/bzip2.png" alt="bzip2" width="auto" height="25">
  - Cpio   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/cpio.webp" alt="cpio" width="auto" height="25">
  - Dandified YUM (DNF)   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/dnf.jpeg" alt="dnf" width="auto" height="25">
  - DPKG   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/dpkg.webp" alt="dpkg" width="auto" height="25">
  - Gzip/Gunzip   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/gzip.png" alt="gzip" width="auto" height="25">
  - Tar   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/tar.jpeg" alt="tar" width="auto" height="25">
  - Unrar   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/unrar.png" alt="unrar" width="auto" height="25">
  - XZ Utils/Unxz   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/xz.png" alt="xz" width="auto" height="25">
  - Yellowdog Updater Modified (YUM)   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/yum.jpg" alt="yum" width="auto" height="25">
  - Zen / YaST Packages Patches Patterns Products (Zypp)   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/zypp.webp" alt="zypp" width="auto" height="25">

---

<a name="item0"><h3>Course Strcuture:</h3></a>
1. <a href="#item01">Aula 01: Editores de Texto</a><br>
2. <a href="#item02">Aula 02: Gerenciamento de Pacotes</a><br>
3. <a href="#item03">Aula 03: Empacotadores e Compactadores de Arquivos</a><br>
4. <a href="#item04">Aula 04: Raio-X do seu Hardware e Gerenciamento de Processos</a><br>
5. <a href="#item05">Laboratórios</a><br>

---

### Objective:
Esse curso teve como objeto abordar os seguintes assuntos do sistema operacional **GNU/Linux**: editores de textos, gerenciadores de pacotes, empacotadores e compactadores de arquivos, gerenciamento de processos e como é organizado o sistema operacional **GNU/Linux**. 

### Structure:
- O curso foi dividido em quatro aulas e três laboratórios (dentro da plataforma do curso).

### Development:

Todo conteúdo foi explicado neste arquivo de README, não sendo necessário nenhum outro arquivo. Os laboratórios foram executado na maquina virtual da plataforma do curso.

<a name="item01"><h4>Aula 01: Editores de Texto</h4></a>[Back to summary](#item0)

Na primeira aula deste curso, que foi teórica, foi abordado sobre os editores de textos do sistema operacional **Linux**. Foi explicado sobre os principais editores de texto existentes para sistemas GNU/Linux: **Vi**, **Vim**, **Nano**, **Joe**, **Pico**, **Mcedit**, **Ed** e **Emacs**. Desses citados, foi apresentado os comandos e atalhos do **Nano** que é o editor de texto padrão do **Debian** e as distribuições baseadas nele. Também foi mostrado comandos e atalhos do editor de texto **Vim** que é a versão aprimorada do editor **Vi**. O **Vim** tem uma particularidade que é essencial para o aprendizado, que são seus modos de trabalho: modo de comandos e modo de edição. No modo de comando, o **Vim** é utilizado para manipular o arquivo, podendo executar tarefas de automação, como copiar ou apagar uma sequência de linhas, ou tarefas de gerenciamento do próprio arquivo, como salvar o arquivo simplesmente ou salvá-lo com nome e caminho diferentes, entre outras tarefas. Já no modo de edição é quando o texto será realmente escrito.

<a name="item02"><h4>Aula 02: Gerenciamento de Pacotes</h4></a>[Back to summary](#item0)

Na segunda aula que também foi teórica, foi explicado sobre o gerenciamento de pacotes e mostrado alguns dos principais gerenciados de pacotes e para quel distribuição **Linux** eles são. O **Apt-Get** e **Aptitude** são gerenciadores de alto nível para distribuições baseada em **Debian**, enquanto o **Dkpg** é o gerenciador padrão de baixo nível para essa distribuição.  O **Yum** que é bastante parecido com os gerenciadores apt-get e aptitude, é usado nas distribuições **Red Hat**. Já o **Dnf** é a ferramenta de gerenciamento de pacotes usada no **Fedora**, é um fork do yum. Também foi apresentado os principais comandos desses softwares e onde ficam armazenados seu arquivo de configuração e os repositórios instalados por eles.

<a name="item03"><h4>Aula 03: Empacotadores e Compactadores de Arquivos</h4></a>[Back to summary](#item0)

Na terceira aula, mais uma aula teórica, foi abordado sobre os softwares empacotadores e compactadores e seus principais comandos. Entre os softwares empacotadores foi apresentado o **Tar** e o **Cpio**. O **Tar** pode ser utilizado junto com compactadores, logo o arquivo é empacotado e compactado. O empacotamento é o ato de aglutinar arquivos e diretórios em um único arquivo. Já a compressão/compactação toma um conjunto de dados e codifica-o de uma maneira que permita seu armazenamento num espaço menor. Entre os compactadores foi explicado sobre o **Gzip** e o **Bzip2**. Ambos possuem um comando adicional só para a realizar a descompactação/descompressão que é utilizando o **Gunzip** e **Bunzip2**. Também foi mostrado o utilitário **Xz** que é utilizado para compressão, enquanto o **Unxz** realiza a descompressão. Por fim, foi explicado sobre backup e os três tipos existentes: backup completo, bakcup incremental e bakcup diferencial. O backup completo salva todos os dados, independente de já terem sido salvos ou não em backups anteriores, portanto os objetos são armazenados completamente. Os backups incremental e diferencial podem ser definidos pela sua relação com o último backup completo realizado. O backup diferencial salva as diferenças em relação ao backup completo, de forma que serão salvos, em cada backup diferencial, os dados adicionais ao último backup completo.

<a name="item04"><h4>Aula 04: Raio-X do seu Hardware e Gerenciamento de Processos</h4></a>[Back to summary](#item0)

Na última aula do curso, foi explicado sobre como é organizado o hardware de um sistema operacional **GNU/Linux**. Entre os pontos explanados, foi apresentado o subdiretório `/dev`
que é um sistema de arquivos especial onde estão localizados todos os arquivos referentes aos dispositivos do computador, exceto a interface de rede, manipulada diretamente
no nível do kernel. Fora ela, praticamente todos os dispositivos de hardware têm um arquivo correspondente no diretório `/dev`. Também foi comentado sobre os arquivos de dispositivos, no qual um dispositivo é acessado por meio de seu respectivo arquivo de dispositivo no diretório `/dev`, e como são organizados os dispositivos de armazenamento. Outro ponto da aula que foi explicado foi a diferença entre os gerenciadores de dispositivos desse sistema operacional, o `udev` e o `devfs`. Com relação ao sistemas de arquivos foi ensiando sobre a sua estrutura básica e como é feito o gerenciamento através de ferramentas específicas.

Já sobre os processos foi explicado a definição de um processo, que pode ser um programa ou comando que, ao ser executado, passa a consumir determinados recursos do sistema e de hardware. Sempre que houver o consumo de algum tipo de recurso por parte de alguma aplicação, programa, comando, etc., teremos, então, um processo. Foram apresentados os seguintes comandos relacionados a processo e explicado como utilizá-los: `top`, `htop`, `ps`, `pidof`, `pstree`, `jobs`, `bg`, `fg`, `kill`, `killall`, `nice`, `renice` e `nohup`. 

<a name="item05"><h4>Laboratórios</h4></a>[Back to summary](#item0)

##### Lab 1: (15:03)
Com a conclusão da primeira, foi realizado o laboratório 1, onde foram executados algumas ações utilizando alguns comandos. Primeiro foi criado um arquivo de texto com o software editor de texto **Vim**, escrevendo uma mensagem nele, salvando e fechando o arquivo. Depois, foi novamente aberto o arquivo e no modo de comandos (digitar `esc` para esse modo) foi digitado o comando `:%s/Software/Source/g` para alterar a palavra `Software` por `Source`. No exercício seguinte foi aberto o arquivo de novo no modo de comandos, copiado e colado a primeira linha com o comando `yyp`, e então digitando o comando `:1;2y` foi copiado o intervalo da linha 1 até a 2 e colado esse intervalo com `p`, salvando e saindo do arquivo com o comando `:wq`. Continuando, foi aberto o arquivo e no modo de comandos digitado `?4Linux` para procurar esse conjunto de caracteres de baixo para cima, confirmando com `enter` e subindo com o `n`. Novamente no arquivo no modo de comandos foi utilizado o comando `:set hlsearch` que serve para localizar palavras iguais. Já com o comando `:!cat /etc/issue.net` foi inserido o comando `cat /etc/issue.net` no final do arquivo. Por fim, foi criado um novo arquivo com o **Vim** e ativado o modo de sytanx com o comando `: sytanx on`, e então foi escrito um comando python.

##### Lab 2: (12:03)
Com a conclusão da segunda aula, foi realizado o laboratório 2. Neste laboratório foi inserido um repositório na soruces.list, em seguida, foi executado os comandos `apt-get update` para atualização dos pacotes e `apt-get upgrade` para atualização do sistema. Com o comando `apt-get remove nmap` foi desinstalado o software **Nmap**. Com o comando `apt-get clean` foi realizado a limpeza do cache do **Apt-Get**. Na sequência, com o comando `aptitude search make` foi localizado o pacote **Make**. Já com o comando `aptitude show make` foi exibindo as informações desse pacote. Com o comando `aptitude install figlet` foi instalado o pacote **Figlet**. Enquanto com o comando `aptitude purge ntp`, o ntp foi removido. Por fim, com o comando `aptitude -f install` foi corrijido as dependências de instalação dos pacotes caso houvesse algum erro.

##### Lab 3: (06:28)
Com a conclusão da quarta aula foi realizado o último laboratório. Com o comando `pstree` foi exibido os processos em formato de árvore. Já com o comando `ps aux` foram filtradas as informações sobre os processos. Na atividade seguinte foi utilizado o comando `ps aux` novamente para identificar o número do processo (`pid`) `tail -f /dev/random` e alterar a prioridade do processo com o comando `renice -n 10 pid`. Para pausar o processo foi utilizado o comando `kill -19 pid`. Já com o comando `jobs`, todos os processos em segundo plano eram listados. O processo `tail -f /dev/random` que estava em segundo plano ao ser pausado foi enviado de volta para o primeiro plano com o comando `fg 2`, sendo `2` o número do processo listado no comando `jobs`. Como este comando ficava preso, foi utilizado o atalho `Ctrl + C` para interrompe-lo. Na atividade seguinte, foi executado o comando `nohup ping 4linux.com.br &` que ficava rodando em segundo plano. Por fim, com o comando `fuser -u /bin/ping` foi exibido o usuário que executou o comando `ping`.